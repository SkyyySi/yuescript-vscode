from _G import require, pcall, assert, type, print, select, tostring, io, os, string


macro LOG = (...) ->
	--const argc = select("#", ...)
	const argv = { ... }

	const joined = table.concat(argv, ", ")

	[[do
		const __io_stderr__ = io.stderr
		__io_stderr__::write(
			"\027[1;35m[\027[34mSERVER\027[35m]\027[22;39m "
			string.format(]] .. joined .. [[)
			"\027[0m\n"
		)
		__io_stderr__::flush()
	]]


macro LOG_VAR = (varname) ->
	[[do
		const __quoted_name__ = (]] .. string.format("%q", varname)::gsub([[#]], [[\#]]) .. [[)
		const __value__ = (]] .. varname .. [[)
		const __type_of_value__ = type(__value__)
		const __quoted_value__ = if __type_of_value__ == "string"
			string.format("%q", __value__)
		else
			tostring(__value__)

		$LOG("\027[31m%s\027[2;39m: \027[36m%s\027[22m \027[35m=\027[33m %s", __quoted_name__, __type_of_value__, __quoted_value__)
	]]


(...) <- xpcall(_, ((err) ->
	from "yue" import traceback
	io.stderr::write(traceback(tostring(err)))
	io.stderr::flush()
	os.exit(1)
), ...)


const try_require = (modname) ->
	assert(type(modname) == "string")

	const has_module, module = pcall(require, modname)

	if has_module
		module


const json = try_require("cjson") ?? try_require("json")
assert(type(json) == "table")

from json import encode, decode, null
assert(type(encode) == "function")
assert(type(decode) == "function")
--assert(null == nil or type(null) == "userdata")


const eprintf = (format_string, ...) ->
	io.stderr::write(string.format(format_string, ...), "\n")
	io.stderr::flush()


const read_message = () ->
	local length = nil

	while true
		const line = io.read("*l")
		--$LOG_VAR(line)

		if line == nil
			return nil
		elseif line == ""
			break

		if length_str := string.match(line, "^Content%-Length: (%d+)\r?$")
			--$LOG_VAR(length_str)
			length = assert(tonumber(length_str))
			io.read("*l")
				|> assert()
				|> string.match("^\r?$")
				|> assert()
			break
		--[[ else
			eprintf(
				">>> %q:%d - WARNING: could not determine content length\n" ..
				"    from header line %q!"
				$FILE
				$LINE
				line
			) --]]

	--$LOG_VAR(length)
	if length == nil
		return nil

	const message = io.read(length)
	--$LOG_VAR(message)
	message


const send_message = (id, payload) ->
	assert(id != nil)
	assert(type(payload) == "table")

	payload.id ??= id
	payload.jsonrpc ??= "2.0"

	local encoded_payload = encode(payload)

	const message = string.format(
		"Content-Length: %d\r\n\r\n%s"
		#encoded_payload
		encoded_payload
	)
	$LOG_VAR(message)
	io.write(message)
	io.flush()


const handle_initialize = (id) ->
	send_message(id, {
		result: {
			capabilities: {
				textDocumentSync: 1 -- "TextDocumentSyncKind.Full"
			}
		}
	})


const handle_shutdown = (id) ->
	send_message(id, {
		result: null
	})


const handle_exit = () ->
	$LOG("Exit request recieved, goodbye!")
	os.exit(0)


const main = (argv=[]) ->
	local count = 0
	while true
		count += 1
		--$LOG_VAR(count)

		const raw = read_message()
		--$LOG_VAR(raw)

		if raw == nil
			--[[ eprintf(">>> No more messages to read, exiting") --]]
			break

		const raw_decode_ok, msg = pcall(decode, raw)
		--[[ eprintf(
			">>> raw_decode_ok: %s = %s, msg: %s = %s"
			type(raw_decode_ok)
			raw_decode_ok
			type(msg)
			type(msg) == "string" and "%q"::format(msg) or tostring(msg)
		) --]]

		if (not raw_decode_ok) or (type(msg) != "table")
			--$LOG_VAR(raw_decode_ok)
			--$LOG_VAR(ok)
			continue

		const { :method, :id } = msg
		--assert(method != nil, "`msg.method` is nil!")
		--assert(id != nil,     "`msg.id` is nil!")

		$LOG_VAR(method)

		switch method
			when "initialize"
				handle_initialize(id)
			when "initialized"
				-- No response needed
			when "textDocument/didOpen"
				-- No-op
			when "shutdown"
				handle_shutdown(id)
			when "exit"
				handle_exit()
			else
				eprintf("[SERVER] >>> ERROR: Unknown LSP method %q!", method)

				if id == nil
					continue

				send_message(id, {
					error: {
						code: -32601
						message: string.format("Method %q not found", method)
					}
				})

		--


if select("#", ...) == 0
	os.exit(main(arg))
