from _G import require, pcall, assert, type, print, select, os

const try_require = (modname) ->
	assert(type(modname) == "string")

	const has_module, module = pcall(require, modname)

	if has_module
		module

const json = try_require("cjson") ?? try_require("json")
assert(type(json) == "table")

from json import encode, decode
assert(type(encode) == "function")
assert(type(decode) == "function")


const eprintf = (format_string, ...) ->
	io.stderr::write(string.format(format_string, ...), "\n")
	io.stderr::flush()


const read_message = () ->
	local length = nil

	while true
		const line = io.read("*l")
		--eprintf(">>> %q:%d - line: %s = %q", $FILE, $LINE, type(line), line)

		if line == nil
			return nil
		elseif line == ""
			break

		if length_str := string.match(line, "^Content%-Length: (%d+)\r?$")
			--eprintf(">>> length_str = %q", length_str)
			length = assert(tonumber(length_str))
			--eprintf(">>> length = %d", length)
			io.read("*l")
				|> assert()
				|> string.match("^\r?$")
				|> assert()
			break
		--[[ else
			eprintf(
				">>> %q:%d - WARNING: could not determine content length\n" ..
				"    from header line %q!"
				$FILE
				$LINE
				line
			) --]]

	--eprintf(">>> length = %s", length)

	if length == nil
		return nil

	const result = io.read(length)
	eprintf(">>> %q:%d - result: %s = %q", $FILE, $LINE, type(result), result)
	result


const send_message = (id, payload) ->
	assert(id != nil)
	assert(type(payload) == "table")

	payload.id ??= id
	payload.jsonrpc ??= "2.0"

	local encoded_payload = encode(payload)

	io.write(string.format(
		"Content-Length: %d\r\n\r\n%s"
		#encoded_payload
		encoded_payload
	))
	io.flush()


const handle_initialize = (id) ->
	send_message(id, {
		result: {
			capabilities: {
				textDocumentSync: 1 -- "TextDocumentSyncKind.Full"
			}
		}
	})


const handle_shutdown = (id) ->
	send_message(id, {
		result: nil
	})


const handle_exit = () ->
	eprintf("\n>>> Exit request recieved, goodbye!")
	os.exit(0)


const main = (argv=[]) ->
	local count = 0
	while true
		count += 1
		eprintf(">>> count = %d", count)
		const raw = read_message()

		if raw == nil
			eprintf(">>> No more messages to read, exiting")
			break

		const raw_decode_ok, msg = pcall(decode, raw)
		eprintf(
			">>> raw_decode_ok: %s = %s, msg: %s = %q"
			type(raw_decode_ok)
			raw_decode_ok
			type(msg)
			msg
		)

		if (not raw_decode_ok) or (type(msg) != "table")
			continue

		const { :method, :id } = msg
		--assert(method != nil, "`msg.method` is nil!")
		--assert(id != nil,     "`msg.id` is nil!")

		eprintf(">>> method = %q", method)

		switch method
			when "initialize"
				handle_initialize(id)
			when "initialized"
				-- No response needed
			when "textDocument/didOpen"
				-- No-op
			when "shutdown"
				handle_shutdown(id)
			when "exit"
				handle_exit()
			else
				eprintf("ERROR: Unknown LSP method %q!", method)

				if id == nil
					continue

				send_message(id, {
					error: {
						code: -32601
						message: string.format("Method %q not found", method)
					}
				})

		--


if select("#", ...) == 0
	os.exit(main(arg))
