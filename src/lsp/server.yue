from _G import require, pcall, assert, type, print, select, os

const try_require = (modname) ->
	assert(type(modname) == "string")

	const has_module, module = pcall(require, modname)

	if has_module
		module

const json = try_require("cjson") ?? try_require("json")
assert(type(json) == "table")

from json import encode, decode
assert(type(encode) == "function")
assert(type(decode) == "function")


const eprintf = (format_string, ...) ->
	io.stderr::write(string.format(format_string, ...), "\n")
	io.stderr::flush()


const read_message = () ->
	local length = nil

	while true
		const line = io.read("*l")
		--eprintf(">>> %q:%d - line: %s = %q", $FILE, $LINE, type(line), line)

		if line == nil
			return nil
		elseif line == ""
			break

		if length_str := string.match(line, "^Content%-Length: (%d+)")
			length = assert(tonumber(length_str))

	--eprintf(">>> length = %s", length)

	if length == nil
		return nil

	const result = io.read(length)
	eprintf(">>> %q:%d - result: %s = %q", $FILE, $LINE, type(result), result)
	result


const send_message = (id, payload) ->
	assert(id != nil)
	assert(type(payload) == "table")

	payload.id ??= id
	payload.jsonrpc ??= "2.0"

	local encoded_payload = encode(payload)

	io.write(string.format(
		"Content-Length: %d\r\n\r\n%s",
		#encoded_payload,
		encoded_payload,
	))
	io.flush()


const handle_initialize = (id) ->
	send_message(id, {
		result: {
			capabilities: {
				textDocumentSync: 1 -- "TextDocumentSyncKind.Full"
			}
		}
	})


const handle_shutdown = (id) ->
	send_message(id, {
		result: nil
	})


const handle_exit = () ->
	print("\nExit request recieved, goodbye!")
	os.exit(0)


const main = (argv=[]) ->
	while true
		const raw = read_message()

		if raw == nil
			break

		const raw_decode_ok, msg = pcall(decode, raw)

		if (not raw_decode_ok) or (type(msg) != "table")
			continue

		const { :method, :id } = msg
		--assert(method != nil, "`msg.method` is nil!")
		--assert(id != nil,     "`msg.id` is nil!")

		switch method
			when "initialize"
				handle_initialize(id)
			when "initialized"
				-- No response needed
			when "textDocument/didOpen"
				-- No-op
			when "shutdown"
				handle_shutdown(id)
			when "exit"
				handle_exit()
			else
				eprintf("ERROR: Unknown LSP method %q!", method)

				if id == nil
					continue

				send_message(id, {
					error: {
						code: -32601
						message: string.format("Method %q not found", method)
					}
				})

		--


if select("#", ...) == 0
	os.exit(main(arg))
